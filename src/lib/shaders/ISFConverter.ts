import { ShaderPreset } from './presets';

export interface ISFShader {
  ISFVSN: string;
  DESCRIPTION: string;
  CREDIT: string;
  CATEGORIES: string[];
  INPUTS: ISFInput[];
  fragmentShader: string;
}

interface ISFInput {
  NAME: string;
  TYPE: string;
  DEFAULT?: number | number[];
  MIN?: number;
  MAX?: number;
  LABEL?: string;
}

/**
 * Converts a WebGL shader preset to ISF (Interactive Shader Format) for VDMX
 * ISF Spec: https://docs.vidvox.net/freetype_isf_ref.html
 */
export class ISFConverter {
  static convertPreset(preset: ShaderPreset): ISFShader {
    const inputs: ISFInput[] = Object.entries(preset.uniforms).map(([name, config]) => {
      const input: ISFInput = {
        NAME: name,
        TYPE: this.mapTypeToISF(config.type),
        LABEL: config.label,
      };

      if (config.type === 'float') {
        input.DEFAULT = config.default as number;
        input.MIN = config.min;
        input.MAX = config.max;
      } else if (config.type === 'vec3') {
        input.DEFAULT = config.default as number[];
      }

      return input;
    });

    // Add standard ISF uniforms
    inputs.push({
      NAME: 'RENDERSIZE',
      TYPE: 'vec2',
      LABEL: 'Resolution',
    });

    const fragmentShader = this.convertShaderCode(preset.fragmentShader, preset.uniforms);

    return {
      ISFVSN: '2.0',
      DESCRIPTION: preset.description,
      CREDIT: 'Generated by LaneyGen',
      CATEGORIES: [preset.category === 'background' ? 'Generator' : 'Filter'],
      INPUTS: inputs,
      fragmentShader,
    };
  }

  private static mapTypeToISF(type: string): string {
    const typeMap: Record<string, string> = {
      float: 'float',
      vec2: 'point2D',
      vec3: 'color',
    };
    return typeMap[type] || type;
  }

  private static convertShaderCode(
    shaderCode: string,
    uniforms: Record<string, any>
  ): string {
    let converted = shaderCode;

    // Replace uResolution with RENDERSIZE (ISF standard)
    converted = converted.replace(/uniform\s+vec2\s+uResolution;/g, '');
    converted = converted.replace(/uResolution/g, 'RENDERSIZE');

    // Replace uSeed with TIME (ISF standard for animation)
    converted = converted.replace(/uniform\s+float\s+uSeed;/g, '');
    converted = converted.replace(/uSeed/g, 'TIME');

    // Remove existing uniform declarations (ISF auto-generates them)
    Object.keys(uniforms).forEach((uniformName) => {
      const uniformRegex = new RegExp(
        `uniform\\s+\\w+\\s+${uniformName};`,
        'g'
      );
      converted = converted.replace(uniformRegex, '');
    });

    // Replace gl_FragColor with ISF's output (GLSL 1.20 compatibility)
    converted = converted.replace(/gl_FragColor/g, 'gl_FragColor');

    return converted.trim();
  }

  static exportAsFile(preset: ShaderPreset): Blob {
    const isf = this.convertPreset(preset);
    const content = `/*{
  "ISFVSN": "${isf.ISFVSN}",
  "DESCRIPTION": "${isf.DESCRIPTION}",
  "CREDIT": "${isf.CREDIT}",
  "CATEGORIES": ${JSON.stringify(isf.CATEGORIES)},
  "INPUTS": ${JSON.stringify(isf.INPUTS, null, 2)}
}*/

${isf.fragmentShader}
`;
    return new Blob([content], { type: 'text/plain' });
  }

  static exportAllAsZip(presets: ShaderPreset[]): Promise<Blob> {
    return import('jszip').then((JSZip) => {
      const zip = new JSZip.default();
      
      presets.forEach((preset) => {
        const blob = this.exportAsFile(preset);
        zip.file(`${preset.id}.fs`, blob);
      });

      const readme = `# ISF Shader Pack - Generated by LaneyGen

## Installation
1. Copy all .fs files to your VDMX ISF folder:
   - macOS: ~/Library/Graphics/ISF/
   - Or use VDMX preferences to set custom ISF directory

2. Restart VDMX or click "Rescan ISF Files" in the Layer Source browser

## Usage
- Find these shaders in the Layer Source browser under "Generator" or "Filter"
- Drag onto a layer to apply
- Adjust parameters in the Layer Controls panel

## OSC Control
Each parameter can be controlled via OSC:
/layer/N/fx/PARAMETER_NAME value

See main documentation for OSC address schema.

Generated: ${new Date().toISOString()}
`;
      zip.file('README.txt', readme);

      return zip.generateAsync({ type: 'blob' });
    });
  }
}
